'''this file solves the hydrodynamics in hydro() and the wave elevation
in elevation(). hydro() will also use Capytaine's built in RAO solver if
controls=False. elevation() will compute the elevation due to incident 
waves, diffracted waves, and radiated waves, as well as multiply the
radiated waves generated by each body by the body's RAO and sum the 
radiated wave fields of every body before adding them to the incident
and diffracted. The math is detailed in the paper.'''

def hydro(array,B,depth,w,char_dim,farm,controls,point_absorber):
    import capytaine as cpt
    import numpy as np
    import PTO

    g = 9.81            # gravitational constant (m/s^2)
    k = w**2/g      # wave number infinite depth (rad^2/m)
    lam = int(2*np.pi/k)    # wavelength infinite depth (m)
    
    # solving hydrodynamics using Capytaine solver
    solver = cpt.BEMSolver()
    diff_prob = cpt.DiffractionProblem(body=array, wave_direction=B, water_depth=depth,omega=w)
    diff_result = solver.solve(diff_prob,keep_details=(True))
    rad_prob = [
        cpt.RadiationProblem(body=array, radiating_dof=dof, water_depth=depth,omega=w)
        for dof in array.dofs
        ]
    rad_result = solver.solve_all(rad_prob,keep_details=(True))
    dataset = cpt.assemble_dataset(rad_result + [diff_result])

    # Capytaine's built in RAO function
    RAO = cpt.post_pro.rao(dataset, wave_direction=B)#, dissipation=None, stiffness=None)
    RAO_vals = RAO.values

    ## This loop applies Budal's upper bound specifically to the RAO of the ##
    ## point absorber (only problematic body). Equation can be found in     ##
    ## Falnes and Kurniawan (2020) Eq. (6.69). The real part of the RAO is  ##
    ## reduced until the condition is met.                                  ##
    print('uncontrolled rao',RAO_vals)
    if controls == False:
        if point_absorber:
            amplitude = 1.000  # unit wave amplitude [m]
            body_velocity = RAO_vals * 1j * w
            print('Initial body velocity:', np.abs(body_velocity))
            # Create a mask for elements that satisfy the condition
            mask = np.abs(body_velocity) > amplitude * w
            while np.any(np.abs(body_velocity[mask]) > amplitude * w):
                # Apply condition to modify the array elements
                RAO_vals[mask] = 0.99*(np.real(RAO_vals[mask]) + 1j * (np.imag(RAO_vals[mask])))
                body_velocity[mask] = RAO_vals[mask] * 1j * w
                # Update the mask after modification
                mask = np.abs(body_velocity) > amplitude * w

            print('Updated body velocity:', np.abs(body_velocity))
            print('Magnitude of RAO_vals:', np.abs(RAO_vals))

    if controls == True:
        RAO_controlled, CWR = PTO.RAO(diff_prob,diff_result,dataset,array,w,farm,char_dim,point_absorber)
        RAO_vals = RAO_controlled
        print('controlled rao',RAO_vals)
    else:
        CWR = 0
    return diff_result,rad_result,RAO_vals,lam,CWR

def elevation(res,lam,diff_result,rad_result,RAO_vals,farm,rad,controls,N,attenuator,rel_dim):
    import numpy as np
    from capytaine.bem.airy_waves import airy_waves_free_surface_elevation
    import capytaine as cpt
    import matplotlib.pyplot as plt

    solver = cpt.BEMSolver()

    # defining the computational grid and preparing post-process data
    x1, x2, y1, y2 = -(lam + rel_dim), (lam + rel_dim), -100, 100
    ny = int(res*(abs(y1)+y2))
    nx = int(res*(abs(x1)+x2))
    grid = np.meshgrid(np.linspace(x1, x2, nx), np.linspace(y1, y2, ny))
    diffraction = solver.compute_free_surface_elevation(grid, diff_result)  # wave el due to diffraction

    # these for-loops and if-statements handle the radiated wave field for
    # different cases of arrays or single bodies 

    multiplications = []
    if attenuator == True:
        single = 2
        multiple = single*N
    else:
        single = 1
        multiple = 3
    if farm == False:
        for i in range(single):
            if controls:
                mult_result = solver.compute_free_surface_elevation(grid, rad_result[i]) * np.abs(RAO_vals[i])
                multiplications.append(mult_result)
            else:
                mult_result = solver.compute_free_surface_elevation(grid, rad_result[i]) * np.abs(RAO_vals[0,i])
                multiplications.append(mult_result)
    else:
        for i in range(multiple):
            if controls:
                mult_result = solver.compute_free_surface_elevation(grid, rad_result[i]) * RAO_vals[i]
                multiplications.append(mult_result)
            else:
                mult_result = solver.compute_free_surface_elevation(grid, rad_result[i]) * RAO_vals[0,i]
                multiplications.append(mult_result)
    radiation = sum(multiplications)
    if rad == False:
        radiation = 0
    incoming_fse = airy_waves_free_surface_elevation(grid, diff_result)     # incident wave el
    total = diffraction + incoming_fse + radiation                 # total wave el

    #### here, you can plot the wave field if you would like. This is where ###
    #### I generate my wave field plots for the paper #########################
    
    # import matplotlib.patheffects as path_effects
    # xtrans = np.array([50,0,50])                        # x translation of bodies if farm
    # ytrans = np.array([50,0,-50])
    # # plots
    # Z = np.real(total)
    # X = grid[0]
    # Y = grid[1]
    # pcm = plt.pcolormesh(X, Y, Z)
    # plt.xlabel("x")
    # plt.ylabel("y")
    # colorbar = plt.colorbar()
    # colorbar.set_label(r"Total Wave Elevation, $\eta$")
    # pcm.set_clim([-2, 2])
    # # # Add markers with black outline
    # # plt.scatter(xtrans, ytrans, marker='_', color='red', s=200, edgecolor='black', linewidth=3)
    # # # Add arrow with black outline
    # # plt.arrow(-100, 50, 50, 0, color='black', width=0.3, head_width=7, head_length=7)
    # # plt.arrow(-100, 50, 50, 0, color='red', width=0.2, head_width=5, head_length=5)

    # # Add text with black outline
    # #text = plt.text(-75, 75, 'Incident Waves', color='red', fontsize=12, ha='center', va='center')
    # #text.set_path_effects([path_effects.Stroke(linewidth=3, foreground='black'), path_effects.Normal()])

    # plt.tight_layout()
    # print('tip')
    # plt.savefig('test_field.pdf')
    # print('top')
    # #plt.show()

    return total, incoming_fse, x1, x2, nx, y1, y2, ny